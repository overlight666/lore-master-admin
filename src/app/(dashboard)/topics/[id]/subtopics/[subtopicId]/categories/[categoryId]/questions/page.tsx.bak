'use client';

import { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import AdminLayout from '@/components/AdminLayout';
import { ArrowLeft, Plus, Edit, Trash2, BookOpen, ChevronRight, Layers, Target, HelpCircle, Upload, FileText, AlertTriangle } from 'lucide-react';
import { Topic, Subtopic, Category, Question } from '@/types';
import { topicsApi, subtopicsApi, categoriesApi, questionsApi, levelsApi } from '@/services/api';
import toast from 'react-hot-toast';

export default function CategoryQuestionsPage() {
  const params = useParams();
  const router = useRouter();
  const topicId = params?.id as string;
  const subtopicId = params?.subtopicId as string;
  const categoryId = params?.categoryId as string;
  
  const [topic, setTopic] = useState<Topic | null>(null);
  const [subtopic, setSubtopic] = useState<Subtopic | null>(null);
  const [category, setCategory] = useState<Category | null>(null);
  const [questions, setQuestions] = useState<Question[]>([]);
  const [filteredQuestions, setFilteredQuestions] = useState<Question[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedLevel, setSelectedLevel] = useState('');
  const [levels, setLevels] = useState<number[]>([]);
  const [showBulkImportModal, setShowBulkImportModal] = useState(false);

  useEffect(() => {
    if (topicId && subtopicId && categoryId) {
      loadData();
    }
  }, [topicId, subtopicId, categoryId]);

  useEffect(() => {
    filterQuestions();
  }, [questions, searchTerm, selectedLevel]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      const [topicData, subtopicData, categoryData, questionsData] = await Promise.all([
        topicsApi.getById(topicId),
        subtopicsApi.getById(subtopicId),
        categoriesApi.getById(categoryId),
        questionsApi.getAll({ topicId, subtopicId, categoryId, limit: 1000 })
      ]);
      
      // Handle data responses
      setTopic(topicData);
      setSubtopic(subtopicData);
      setCategory(categoryData);
      
      // Handle questions data
      const questionsArray = questionsData?.data || [];
      setQuestions(questionsArray);
      
      // Extract unique levels from questions
      const uniqueLevels = Array.from(new Set<number>(questionsArray.map((q: Question) => q.level))).sort((a, b) => a - b);
      setLevels(uniqueLevels);
      
    } catch (error: any) {
      console.error('Error loading data:', error);
      toast.error('Failed to load data');
    } finally {
      setIsLoading(false);
    }
  };

  const filterQuestions = () => {
    let filtered = questions;

    if (searchTerm) {
      filtered = filtered.filter(q =>
        q.question.toLowerCase().includes(searchTerm.toLowerCase()) ||
        q.correctAnswer.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }

    if (selectedLevel) {
      filtered = filtered.filter(q => q.level === parseInt(selectedLevel));
    }

    setFilteredQuestions(filtered);
  };

  const handleDeleteQuestion = async (questionId: string) => {
    if (!confirm('Are you sure you want to delete this question?')) {
      return;
    }

    try {
      await questionsApi.delete(questionId);
      toast.success('Question deleted successfully');
      loadData();
    } catch (error: any) {
      console.error('Error deleting question:', error);
      toast.error('Failed to delete question');
    }
  };

  const handleAddQuestion = () => {
    router.push(`/topics/${topicId}/subtopics/${subtopicId}/categories/${categoryId}/questions/create`);
  };

  const handleEditQuestion = (questionId: string) => {
    router.push(`/questions/${questionId}/edit`);
  };

  if (isLoading) {
    return (
      <AdminLayout>
        <div className="animate-pulse space-y-4">
          <div className="h-8 bg-gray-200 rounded w-1/4"></div>
          <div className="h-32 bg-gray-200 rounded"></div>
        </div>
      </AdminLayout>
    );
  }

  return (
    <AdminLayout>
      <div className="space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div className="flex items-center space-x-4">
            <button
              onClick={() => router.push(`/topics/${topicId}/subtopics/${subtopicId}/categories`)}
              className="flex items-center text-blue-600 hover:text-blue-800"
            >
              <ArrowLeft className="h-5 w-5 mr-2" />
              Back to Categories
            </button>
          </div>
        </div>

        {/* Breadcrumb */}
        <div className="bg-white p-4 rounded-lg border">
          <div className="flex items-center text-sm text-gray-600">
            <BookOpen className="h-4 w-4 mr-2" />
            <span className="font-medium text-gray-900">{topic?.name}</span>
            <ChevronRight className="h-4 w-4 mx-2" />
            <span className="font-medium text-gray-900">{subtopic?.name}</span>
            <ChevronRight className="h-4 w-4 mx-2" />
            <Layers className="h-4 w-4 mr-1" />
            <span className="font-medium text-gray-900">{category?.name}</span>
            <ChevronRight className="h-4 w-4 mx-2" />
            <HelpCircle className="h-4 w-4 mr-1" />
            <span>Questions</span>
          </div>
        </div>

        {/* Stats */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
          <div className="bg-white p-6 rounded-lg border">
            <div className="flex items-center">
              <HelpCircle className="h-8 w-8 text-blue-600" />
              <div className="ml-4">
                <p className="text-sm font-medium text-gray-600">Total Questions</p>
                <p className="text-2xl font-bold text-gray-900">{questions.length}</p>
              </div>
            </div>
          </div>
          <div className="bg-white p-6 rounded-lg border">
            <div className="flex items-center">
              <Target className="h-8 w-8 text-green-600" />
              <div className="ml-4">
                <p className="text-sm font-medium text-gray-600">Levels</p>
                <p className="text-2xl font-bold text-gray-900">{levels.length}</p>
              </div>
            </div>
          </div>
          <div className="bg-white p-6 rounded-lg border">
            <div className="flex items-center">
              <HelpCircle className="h-8 w-8 text-orange-600" />
              <div className="ml-4">
                <p className="text-sm font-medium text-gray-600">Filtered</p>
                <p className="text-2xl font-bold text-gray-900">{filteredQuestions.length}</p>
              </div>
            </div>
          </div>
        </div>

        {/* Main Content */}
        <div className="bg-white rounded-lg border">
          <div className="px-6 py-4 border-b border-gray-200">
            <div className="flex items-center justify-between">
              <div>
                <h1 className="text-2xl font-bold text-gray-900">Questions</h1>
                <p className="text-gray-600 mt-1">
                  Manage questions for <span className="font-medium">{category?.name}</span>
                </p>
              </div>
              <div className="flex items-center space-x-2">
                <button
                  onClick={() => setShowBulkImportModal(true)}
                  className="bg-green-600 text-white px-4 py-2 rounded-lg flex items-center gap-2 hover:bg-green-700 transition-colors"
                >
                  <Upload className="h-5 w-5" />
                  Bulk Import
                </button>
                <button
                  onClick={handleAddQuestion}
                  className="bg-blue-600 text-white px-4 py-2 rounded-lg flex items-center gap-2 hover:bg-blue-700 transition-colors"
                >
                  <Plus className="h-5 w-5" />
                  Add Question
                </button>
              </div>
            </div>
          </div>

          {/* Filters */}
          <div className="px-6 py-4 border-b border-gray-200">
            <div className="flex items-center space-x-4">
              <div className="relative flex-1 max-w-md">
                <input
                  type="text"
                  placeholder="Search questions..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="w-full border border-gray-300 rounded-lg py-2 px-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
                />
              </div>
              <select
                value={selectedLevel}
                onChange={(e) => setSelectedLevel(e.target.value)}
                className="border border-gray-300 rounded-lg py-2 px-3 focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option value="">All Levels</option>
                {levels.map(level => (
                  <option key={level} value={level.toString()}>Level {level}</option>
                ))}
              </select>
              <button
                onClick={() => {
                  setSearchTerm('');
                  setSelectedLevel('');
                }}
                className="bg-gray-100 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-200 transition-colors"
              >
                Clear
              </button>
            </div>
          </div>

          {/* Questions List */}
          <div className="p-6">
            {filteredQuestions.length === 0 ? (
              <div className="text-center py-12">
                <HelpCircle className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 mb-2">
                  {questions.length === 0 ? 'No Questions Yet' : 'No Questions Found'}
                </h3>
                <p className="text-gray-500 mb-4">
                  {questions.length === 0 
                    ? 'Get started by creating your first question for this category.'
                    : 'Try adjusting your search or filter criteria.'
                  }
                </p>
                {questions.length === 0 && (
                  <button
                    onClick={handleAddQuestion}
                    className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors"
                  >
                    Create Question
                  </button>
                )}
              </div>
            ) : (
              <div className="space-y-4">
                {filteredQuestions.map((question, index) => (
                  <div key={question.id} className="border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow">
                    <div className="flex items-start justify-between">
                      <div className="flex-1">
                        <div className="flex items-center mb-2">
                          <span className="text-sm font-medium text-gray-500 mr-3">
                            Question {index + 1}
                          </span>
                          <span className={`inline-flex px-2 py-1 text-xs font-semibold rounded-full ${
                            question.level <= 3 ? 'bg-green-100 text-green-800' :
                            question.level <= 6 ? 'bg-yellow-100 text-yellow-800' :
                            question.level <= 8 ? 'bg-orange-100 text-orange-800' :
                            'bg-red-100 text-red-800'
                          }`}>
                            Level {question.level}
                          </span>
                        </div>
                        <h3 className="text-lg font-medium text-gray-900 mb-3">
                          {question.question}
                        </h3>
                        <div className="space-y-1 mb-3">
                          {question.choices?.map((choice, choiceIndex) => (
                            <div 
                              key={choiceIndex} 
                              className={`text-sm p-2 rounded ${
                                choice === question.correctAnswer 
                                  ? 'bg-green-50 text-green-800 font-medium' 
                                  : 'bg-gray-50 text-gray-700'
                              }`}
                            >
                              {String.fromCharCode(65 + choiceIndex)}. {choice}
                              {choice === question.correctAnswer && (
                                <span className="ml-2 text-green-600">✓ Correct</span>
                              )}
                            </div>
                          ))}
                        </div>
                        {question.explanation && (
                          <div className="text-sm text-gray-600 bg-blue-50 p-3 rounded">
                            <strong>Explanation:</strong> {question.explanation}
                          </div>
                        )}
                      </div>
                      
                      <div className="flex items-center space-x-2 ml-4">
                        <button
                          onClick={() => handleEditQuestion(question.id)}
                          className="text-green-600 hover:text-green-900"
                          title="Edit Question"
                        >
                          <Edit className="h-4 w-4" />
                        </button>
                        <button
                          onClick={() => handleDeleteQuestion(question.id)}
                          className="text-red-600 hover:text-red-900"
                          title="Delete Question"
                        >
                          <Trash2 className="h-4 w-4" />
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        </div>
      </div>

      {/* Bulk Import Modal */}
      <BulkImportModal
        isOpen={showBulkImportModal}
        onClose={() => setShowBulkImportModal(false)}
        onSave={loadData}
        topicId={topicId}
        subtopicId={subtopicId}
        categoryId={categoryId}
      />
    </AdminLayout>
  );
}

// Bulk Import Modal Component
interface BulkImportModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: () => void;
  topicId: string;
  subtopicId: string;
  categoryId: string;
}

interface ValidationResult {
  totalQuestions: number;
  validQuestions: number;
  invalidQuestions: ParsedQuestion[];
  duplicatesInFile: ParsedQuestion[];
  duplicatesInDatabase: ParsedQuestion[];
  errors: string[];
  questions: ParsedQuestion[];
}

interface ParsedQuestion {
  question: string; // Change from 'text' to 'question'
  choices: string[];
  correctAnswer: string;
  explanation?: string;
  difficulty: number;
  level_id?: string; // Add level_id field
  lineNumber?: number;
  error?: string;
}

// Validation functions
const parseDocxContent = (content: string): ParsedQuestion[] => {
  const questions: ParsedQuestion[] = [];
  const lines = content.split('\n').map(line => line.trim()).filter(line => line);
  
  let currentQuestion: Partial<ParsedQuestion> = {};
  let lineNumber = 0;
  let expectingChoices = false;
  let choiceLetters = ['A', 'B', 'C', 'D'];
  let currentChoiceIndex = 0;
  
  for (const line of lines) {
    lineNumber++;
    
    // Skip title lines
    if (line.includes('Magic: The Gathering Lore Quiz') || 
        line.includes('Multiple-Choice Questions') ||
        line.includes('MTG Multiverse') ||
        line.match(/^-+$/) ||
        line.toLowerCase().includes('image:')) {
      continue;
    }
    
    // Check for question pattern: "Question X – (Easy/Medium/Hard)"
    const questionMatch = line.match(/Question\s+(\d+)\s*[–-]\s*\((\w+)\)/i);
    
    if (questionMatch) {
      // Save previous question if exists and is complete
      if (currentQuestion.question && currentQuestion.choices && currentQuestion.correctAnswer) {
        questions.push(currentQuestion as ParsedQuestion);
      }
      
      // Start new question
      const difficultyText = questionMatch[2].toLowerCase();
      let difficulty = 1;
      
      switch (difficultyText) {
        case 'easy':
          difficulty = 1;
          break;
        case 'medium':
          difficulty = 2;
          break;
        case 'hard':
          difficulty = 3;
          break;
        default:
          // Try to parse as number
          const num = parseInt(difficultyText);
          if (!isNaN(num) && num >= 1 && num <= 10) {
            difficulty = num;
          }
      }
      
      currentQuestion = { 
        difficulty, 
        choices: [], 
        lineNumber,
        question: '',
        correctAnswer: ''
      };
      expectingChoices = false;
      currentChoiceIndex = 0;
      continue;
    }
    
    // Check for question text (line after question header that's not a choice)
    if (currentQuestion.difficulty && !currentQuestion.question && 
        !line.match(/^[A-D]\)/i) && !line.toLowerCase().startsWith('answer:')) {
      currentQuestion.question = line;
      expectingChoices = true;
      continue;
    }
    
    // Check for choices (A), B), C), D))
    const choiceMatch = line.match(/^([A-D])\)\s*(.+)/i);
    if (choiceMatch && expectingChoices) {
      const [, letter, choiceText] = choiceMatch;
      if (!currentQuestion.choices) currentQuestion.choices = [];
      
      // Ensure we add choices in order
      const expectedLetter = choiceLetters[currentQuestion.choices.length];
      if (letter.toUpperCase() === expectedLetter) {
        currentQuestion.choices.push(choiceText.trim());
        currentChoiceIndex++;
      }
      continue;
    }
    
    // Check for answer - multiple formats
    const answerMatch = line.match(/Answer:\s*([A-D])\)\s*(.+)/i) ||
                       line.match(/Answer:\s*([A-D])/i);
    
    if (answerMatch && currentQuestion.choices) {
      const answerLetter = answerMatch[1].toUpperCase();
      const answerIndex = answerLetter.charCodeAt(0) - 65; // A=0, B=1, C=2, D=3
      
      if (answerIndex >= 0 && answerIndex < currentQuestion.choices.length) {
        currentQuestion.correctAnswer = currentQuestion.choices[answerIndex];
        
        // If there's answer text provided, use it as explanation
        if (answerMatch[2]) {
          currentQuestion.explanation = answerMatch[2].trim();
        }
      }
      continue;
    }
    
    // Check for standalone explanation after answer
    if (currentQuestion.correctAnswer && !currentQuestion.explanation && 
        line.length > 10 && !line.match(/Question\s+\d+/i)) {
      currentQuestion.explanation = line;
    }
  }
  
  // Add last question if complete
  if (currentQuestion.question && currentQuestion.choices && currentQuestion.correctAnswer) {
    questions.push(currentQuestion as ParsedQuestion);
  }
  
  return questions;
};

const parseCSVContent = (content: string): ParsedQuestion[] => {
  const questions: ParsedQuestion[] = [];
  const lines = content.split('\n').map(line => line.trim()).filter(line => line);
  
  if (lines.length === 0) return questions;
  
  // Skip header if present
  const startIndex = lines[0].toLowerCase().includes('level') ? 1 : 0;
  
  for (let i = startIndex; i < lines.length; i++) {
    const line = lines[i];
    const columns = parseCSVLine(line);
    
    if (columns.length >= 7) {
      questions.push({
        difficulty: parseInt(columns[0]) || 1,
        question: columns[1],
        choices: [columns[2], columns[3], columns[4], columns[5]],
        correctAnswer: columns[6],
        explanation: columns[7] || '',
        lineNumber: i + 1
      });
    }
  }
  
  return questions;
};

const parseCSVLine = (line: string): string[] => {
  const result: string[] = [];
  let current = '';
  let inQuotes = false;
  
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      result.push(current.trim());
      current = '';
    } else {
      current += char;
    }
  }
  
  result.push(current.trim());
  return result.map(col => col.replace(/^"|"$/g, ''));
};

const validateQuestions = async (parsedQuestions: ParsedQuestion[], categoryId: string): Promise<ValidationResult> => {
  const result: ValidationResult = {
    totalQuestions: parsedQuestions.length,
    validQuestions: 0,
    invalidQuestions: [],
    duplicatesInFile: [],
    duplicatesInDatabase: [],
    errors: [],
    questions: []
  };
  
  // Get existing questions from database
  let existingQuestions: Question[] = [];
  try {
    const response = await questionsApi.getAll({ categoryId, limit: 1000 });
    existingQuestions = response.data || [];
  } catch (error) {
    result.errors.push('Failed to fetch existing questions from database');
  }
  
  // Track questions for duplicate detection
  const seenTexts = new Set<string>();
  const duplicateTexts = new Set<string>();
  
  // First pass: find duplicates within the file
  parsedQuestions.forEach(q => {
    const normalizedText = q.question.toLowerCase().trim();
    if (seenTexts.has(normalizedText)) {
      duplicateTexts.add(normalizedText);
    }
    seenTexts.add(normalizedText);
  });
  
  // Second pass: validate each question
  parsedQuestions.forEach(question => {
    const normalizedText = question.question.toLowerCase().trim();
    let isValid = true;
    const errors: string[] = [];
    
    // Check required fields
    if (!question.question?.trim()) {
      errors.push('Question text is required');
      isValid = false;
    }
    
    if (!question.correctAnswer?.trim()) {
      errors.push('Correct answer is required');
      isValid = false;
    }
    
    if (!question.choices || question.choices.length < 2) {
      errors.push('At least 2 answer choices are required');
      isValid = false;
    }
    
    if (question.choices && question.choices.some(choice => !choice?.trim())) {
      errors.push('All answer choices must be filled');
      isValid = false;
    }
    
    // Check if correct answer is in choices
    if (question.choices && question.correctAnswer && 
        !question.choices.some(choice => choice.toLowerCase().trim() === question.correctAnswer.toLowerCase().trim())) {
      errors.push('Correct answer must be one of the provided choices');
      isValid = false;
    }
    
    // Check for duplicates in file
    if (duplicateTexts.has(normalizedText)) {
      result.duplicatesInFile.push({ ...question, error: 'Duplicate question in file' });
      isValid = false;
    }
    
    // Check for duplicates in database
    const existsInDb = existingQuestions.some(existing => 
      existing.question.toLowerCase().trim() === normalizedText
    );
    
    if (existsInDb) {
      result.duplicatesInDatabase.push({ ...question, error: 'Question already exists in database' });
      isValid = false;
    }
    
    if (isValid) {
      result.validQuestions++;
      result.questions.push(question);
    } else {
      result.invalidQuestions.push({ ...question, error: errors.join(', ') });
    }
  });
  
  return result;
};

function BulkImportModal({ isOpen, onClose, onSave, topicId, subtopicId, categoryId }: BulkImportModalProps) {
  const [file, setFile] = useState<File | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [dragActive, setDragActive] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [isValidating, setIsValidating] = useState(false);
  const [validationResult, setValidationResult] = useState<ValidationResult | null>(null);
  const [showPreview, setShowPreview] = useState(false);

  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === "dragenter" || e.type === "dragover") {
      setDragActive(true);
    } else if (e.type === "dragleave") {
      setDragActive(false);
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      const droppedFile = e.dataTransfer.files[0];
      if (isValidFile(droppedFile)) {
        setFile(droppedFile);
      } else {
        toast.error('Please select a DOCX or CSV file');
      }
    }
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0];
    if (selectedFile && isValidFile(selectedFile)) {
      setFile(selectedFile);
    } else {
      toast.error('Please select a DOCX or CSV file');
    }
  };

  const isValidFile = (file: File) => {
    return file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ||
           file.type === 'text/csv' ||
           file.name.endsWith('.docx') ||
           file.name.endsWith('.csv');
  };

  const downloadCSVTemplate = () => {
    const csvContent = [
      'level,question,option_a,option_b,option_c,option_d,correct_answer,explanation',
      '1,"Who is known as the Firebrand and was one of the founding members of the Gatewatch?","Liliana Vess","Chandra Nalaar","Jaya Ballard","Elspeth Tirel","Chandra Nalaar","Chandra Nalaar is known as the Firebrand and was one of the founding members of the Gatewatch"',
      '2,"Which plane is home to the Eldrazi titans?","Zendikar","Innistrad","Ravnica","The Blind Eternities","The Blind Eternities","The Eldrazi titans originate from the space between planes known as the Blind Eternities"',
      '3,"What is the name of Jace\'s home plane?","Vryn","Kaladesh","Theros","Ixalan","Vryn","Jace Beleren\'s home plane is Vryn, though he spent much of his early life on Ravnica"'
    ].join('\n');

    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'questions_template.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    toast.success('CSV template downloaded');
  };

  const handleValidateFile = async () => {
    if (!file) {
      toast.error('Please select a file first');
      return;
    }

    setIsValidating(true);
    setValidationResult(null);

    try {
      let parsedQuestions: ParsedQuestion[] = [];

      if (file.name.endsWith('.docx')) {
        // For DOCX files, we need to send to backend for proper parsing
        // But for client-side validation, try to read as text
        try {
          const fileContent = await readFileAsText(file);
          parsedQuestions = parseDocxContent(fileContent);
          
          // If no questions found, might be a binary DOCX file
          if (parsedQuestions.length === 0) {
            toast('DOCX file detected. For best results, please use the import function directly or convert to plain text/CSV format.', {
              icon: '⚠️',
            });
            // Try to use server-side parsing
            const formData = new FormData();
            formData.append('file', file);
            formData.append('topicId', topicId);
            formData.append('subtopicId', subtopicId);
            formData.append('categoryId', categoryId);
            
            const response = await questionsApi.validateDocx(formData);
            if (response.questions) {
              parsedQuestions = response.questions.map((q: any) => ({
                question: q.question || q.text,
                choices: q.choices || [],
                correctAnswer: q.correctAnswer || q.answer,
                explanation: q.explanation || '',
                difficulty: q.difficulty || q.level || 1,
                lineNumber: q.lineNumber
              }));
            }
          }
        } catch (error) {
          console.error('Client-side DOCX parsing failed:', error);
          toast('Using server-side DOCX parsing...', {
            icon: 'ℹ️',
          });
          
          // Fallback to server-side parsing
          const formData = new FormData();
          formData.append('file', file);
          formData.append('topicId', topicId);
          formData.append('subtopicId', subtopicId);
          formData.append('categoryId', categoryId);
          
          const response = await questionsApi.validateDocx(formData);
          if (response.questions) {
            parsedQuestions = response.questions.map((q: any) => ({
              question: q.question || q.text,
              choices: q.choices || [],
              correctAnswer: q.correctAnswer || q.answer,
              explanation: q.explanation || '',
              difficulty: q.difficulty || q.level || 1,
              lineNumber: q.lineNumber
            }));
          } else {
            throw new Error('Failed to parse DOCX file');
          }
        }
      } else if (file.name.endsWith('.csv')) {
        const fileContent = await readFileAsText(file);
        parsedQuestions = parseCSVContent(fileContent);
      } else {
        throw new Error('Unsupported file format. Please use DOCX or CSV files.');
      }

      const validationResult = await validateQuestions(parsedQuestions, categoryId);
      setValidationResult(validationResult);
      setShowPreview(true);

      if (validationResult.errors.length > 0) {
        toast.error(`Validation completed with ${validationResult.errors.length} errors`);
      } else {
        toast.success(`Validation completed: ${validationResult.validQuestions}/${validationResult.totalQuestions} questions are valid`);
      }

    } catch (error: any) {
      console.error('Validation error:', error);
      toast.error('Failed to validate file: ' + error.message);
    } finally {
      setIsValidating(false);
    }
  };

  const readFileAsText = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target?.result as string);
      reader.onerror = (e) => reject(new Error('Failed to read file'));
      reader.readAsText(file, 'UTF-8');
    });
  };

  const handleUpload = async () => {
    if (!validationResult || validationResult.validQuestions === 0) {
      toast.error('Please validate the file first and ensure there are valid questions');
      return;
    }

    setIsUploading(true);
    setUploadProgress(0);

    try {
      // Simulate progress
      const progressInterval = setInterval(() => {
        setUploadProgress(prev => {
          if (prev >= 90) {
            clearInterval(progressInterval);
            return prev;
          }
          return prev + 10;
        });
      }, 200);

      // Get available levels for this category
      let availableLevels: any[] = [];
      try {
        const levelsResponse = await levelsApi.getAll({ category_id: categoryId, limit: 100 });
        availableLevels = levelsResponse.data || [];
      } catch (error) {
        console.error('Failed to fetch levels:', error);
      }

      // Prepare questions for API
      const questionsToCreate = validationResult.questions.map(q => {
        // Find appropriate level based on difficulty or use first available level
        const appropriateLevel = availableLevels.find(level => level.level === q.difficulty) || 
                               availableLevels[0];
        
        return {
          topic_id: topicId,
          subtopic_id: subtopicId,
          category_id: categoryId,
          level_id: appropriateLevel?.id || '',
          question: q.question,
          choices: q.choices,
          correctAnswer: q.correctAnswer,
          explanation: q.explanation || '',
          difficulty: q.difficulty,
          tags: [],
          estimatedTime: 60,
          isActive: true
        };
      });

      // Use bulk create API
      const response = await questionsApi.bulkCreate({
        topicId,
        subtopicId,
        categoryId,
        questionsData: questionsToCreate
      });

      clearInterval(progressInterval);
      setUploadProgress(100);

      if (response.success) {
        toast.success(`Successfully imported ${validationResult.validQuestions} questions`);
        handleClose();
        onSave();
      } else {
        toast.error(response.message || 'Failed to import questions');
      }

    } catch (error: any) {
      console.error('Upload error:', error);
      toast.error('Failed to import questions: ' + (error.response?.data?.error || error.message));
    } finally {
      setIsUploading(false);
      setUploadProgress(0);
    }
  };

  const handleClose = () => {
    setFile(null);
    setValidationResult(null);
    setShowPreview(false);
    setIsValidating(false);
    setIsUploading(false);
    setUploadProgress(0);
    onClose();
  };

  // Test parsing with the exact format from the attachment
  const testSampleParsing = () => {
    const sampleContent = `Magic: The Gathering Lore Quiz

Multiple-Choice Questions Across the MTG Multiverse

Question 1 – (Easy)

Who is known as the Firebrand and was one of the founding members of the Gatewatch?

A) Liliana Vess
B) Chandra Nalaar
C) Jaya Ballard
D) Elspeth Tirel

Answer: B) Chandra Nalaar
Image:

----------------------------------------------------------

Question 2 – (Medium)

Which plane is home to the gothic horror setting featuring vampires, werewolves, and spirits?

A) Ravnica
B) Zendikar
C) Innistrad
D) Dominaria

Answer: C) Innistrad
Image:`;

    console.log('Testing DOCX parsing with sample content...');
    const parsed = parseDocxContent(sampleContent);
    console.log('Parsed questions:', parsed);
    
    // Show results in UI
    toast.success(`Test parsing found ${parsed.length} questions`);
    
    return parsed;
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg p-6 w-full max-w-2xl max-h-[90vh] overflow-y-auto">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-xl font-bold text-gray-900">Bulk Import Questions</h2>
          <button
            onClick={handleClose}
            className="text-gray-400 hover:text-gray-600"
            disabled={isUploading || isValidating}
          >
            ×
          </button>
        </div>

        {/* File Format Info */}
        <div className="mb-6">
          <h3 className="text-lg font-semibold text-gray-900 mb-3">Supported Formats</h3>
          
          {/* DOCX Format */}
          <div className="mb-4 p-4 bg-blue-50 rounded-lg">
            <h4 className="font-medium text-blue-900 mb-2 flex items-center">
              <FileText className="h-4 w-4 mr-2" />
              DOCX Format
            </h4>
            <p className="text-sm text-blue-800 mb-2">Questions should be formatted exactly as shown:</p>
            <div className="bg-white p-3 rounded border text-sm font-mono whitespace-pre-line">
{`Question 1 – (Easy)
Who is known as the Firebrand and was one of the founding members of the Gatewatch?
A) Liliana Vess
B) Chandra Nalaar
C) Jaya Ballard
D) Elspeth Tirel
Answer: B) Chandra Nalaar

Question 2 – (Medium)
Which plane is home to the gothic horror setting featuring vampires, werewolves, and spirits?
A) Ravnica
B) Zendikar
C) Innistrad
D) Dominaria
Answer: C) Innistrad`}
            </div>
            <p className="text-xs text-blue-700 mt-2">
              • Use exact format: "Question [number] – (Easy/Medium/Hard)"<br/>
              • Question text on the next line<br/>
              • Choices as A), B), C), D) each on separate lines<br/>
              • Answer format: "Answer: [letter]) [answer text]"<br/>
              • Separate questions with blank lines
            </p>
            <button
              onClick={testSampleParsing}
              className="bg-purple-600 text-white px-3 py-1 rounded text-sm hover:bg-purple-700 transition-colors mt-2"
            >
              Test DOCX Parsing
            </button>
          </div>

         

          {/* CSV Format */}
          <div className="mb-4 p-4 bg-green-50 rounded-lg">
            <h4 className="font-medium text-green-900 mb-2 flex items-center">
              <FileText className="h-4 w-4 mr-2" />
              CSV Format
            </h4>
            <p className="text-sm text-green-800 mb-2">Download template with required columns:</p>
            <button
              onClick={downloadCSVTemplate}
              className="bg-green-600 text-white px-3 py-1 rounded text-sm hover:bg-green-700 transition-colors"
              disabled={isUploading}
            >
              Download CSV Template
            </button>
          </div>
        </div>

        {/* File Upload Area */}
        <div
          className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
            dragActive
              ? 'border-blue-500 bg-blue-50'
              : file
              ? 'border-green-500 bg-green-50'
              : 'border-gray-300 hover:border-gray-400'
          }`}
          onDragEnter={handleDrag}
          onDragLeave={handleDrag}
          onDragOver={handleDrag}
          onDrop={handleDrop}
        >
          {file ? (
            <div className="space-y-2">
              <FileText className="h-12 w-12 text-green-600 mx-auto" />
              <p className="text-sm font-medium text-green-900">{file.name}</p>
              <p className="text-xs text-green-600">
                {(file.size / 1024 / 1024).toFixed(2)} MB • {file.type}
              </p>
              <button
                onClick={() => setFile(null)}
                className="text-red-600 hover:text-red-800 text-sm"
                disabled={isUploading}
              >
                Remove file
              </button>
            </div>
          ) : (
            <div className="space-y-4">
              <Upload className="h-12 w-12 text-gray-400 mx-auto" />
              <div>
                <p className="text-lg font-medium text-gray-900">Drop your file here</p>
                <p className="text-sm text-gray-500">or click to browse</p>
              </div>
              <input
                type="file"
                accept=".docx,.csv"
                onChange={handleFileChange}
                className="hidden"
                id="file-upload"
                disabled={isUploading}
              />
              <label
                htmlFor="file-upload"
                className="bg-blue-600 text-white px-4 py-2 rounded-lg cursor-pointer hover:bg-blue-700 transition-colors inline-block"
              >
                Choose File
              </label>
            </div>
          )}
        </div>

        {/* Validation Button */}
        {file && !validationResult && (
          <div className="text-center">
            <button
              onClick={handleValidateFile}
              disabled={isValidating}
              className="bg-purple-600 text-white px-6 py-2 rounded-lg hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed flex items-center mx-auto"
            >
              {isValidating ? (
                <>
                  <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></div>
                  Validating...
                </>
              ) : (
                <>
                  <FileText className="h-4 w-4 mr-2" />
                  Validate File
                </>
              )}
            </button>
            <p className="text-sm text-gray-500 mt-2">
              Click to validate questions and check for duplicates
            </p>
          </div>
        )}

        {/* Validation Results */}
        {validationResult && (
          <div className="space-y-4">
            <div className="bg-gray-50 rounded-lg p-4">
              <h3 className="font-semibold text-gray-900 mb-3">Validation Results</h3>
              
              {/* Summary Cards */}
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                <div className="bg-white rounded-lg p-3 text-center">
                  <div className="text-2xl font-bold text-blue-600">{validationResult.totalQuestions}</div>
                  <div className="text-sm text-gray-600">Total Questions</div>
                </div>
                <div className="bg-white rounded-lg p-3 text-center">
                  <div className="text-2xl font-bold text-green-600">{validationResult.validQuestions}</div>
                  <div className="text-sm text-gray-600">Valid Questions</div>
                </div>
                <div className="bg-white rounded-lg p-3 text-center">
                  <div className="text-2xl font-bold text-red-600">{validationResult.invalidQuestions.length}</div>
                  <div className="text-sm text-gray-600">Invalid Questions</div>
                </div>
                <div className="bg-white rounded-lg p-3 text-center">
                  <div className="text-2xl font-bold text-yellow-600">
                    {validationResult.duplicatesInFile.length + validationResult.duplicatesInDatabase.length}
                  </div>
                  <div className="text-sm text-gray-600">Duplicates</div>
                </div>
              </div>

              {/* Error Messages */}
              {validationResult.errors.length > 0 && (
                <div className="bg-red-50 border border-red-200 rounded-lg p-3 mb-4">
                  <h4 className="font-medium text-red-900 mb-2">Validation Errors:</h4>
                  <ul className="list-disc list-inside text-sm text-red-800">
                    {validationResult.errors.map((error, index) => (
                      <li key={index}>{error}</li>
                    ))}
                  </ul>
                </div>
              )}

              {/* Details Toggle */}
              <div className="flex justify-center">
                <button
                  onClick={() => setShowPreview(!showPreview)}
                  className="text-blue-600 hover:text-blue-800 text-sm flex items-center"
                >
                  {showPreview ? 'Hide Details' : 'Show Details'}
                  <ChevronRight className={`h-4 w-4 ml-1 transition-transform ${showPreview ? 'rotate-90' : ''}`} />
                </button>
              </div>
            </div>

            {/* Detailed Preview */}
            {showPreview && (
              <div className="bg-gray-50 rounded-lg p-4 max-h-96 overflow-y-auto">
                {/* Invalid Questions */}
                {validationResult.invalidQuestions.length > 0 && (
                  <div className="mb-4">
                    <h4 className="font-medium text-red-900 mb-2 flex items-center">
                      <AlertTriangle className="h-4 w-4 mr-1" />
                      Invalid Questions ({validationResult.invalidQuestions.length})
                    </h4>
                    <div className="space-y-2">
                      {validationResult.invalidQuestions.map((question, index) => (
                        <div key={index} className="bg-red-50 border border-red-200 rounded p-2 text-sm">
                          <div className="font-medium text-red-900">
                            {question.lineNumber ? `Line ${question.lineNumber}: ` : ''}{question.question || 'Missing question text'}
                          </div>
                          <div className="text-red-600 mt-1">{question.error}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {/* Duplicates */}
                {(validationResult.duplicatesInFile.length > 0 || validationResult.duplicatesInDatabase.length > 0) && (
                  <div className="mb-4">
                    <h4 className="font-medium text-yellow-900 mb-2 flex items-center">
                      <AlertTriangle className="h-4 w-4 mr-1" />
                      Duplicate Questions ({validationResult.duplicatesInFile.length + validationResult.duplicatesInDatabase.length})
                    </h4>
                    <div className="space-y-2">
                      {[...validationResult.duplicatesInFile, ...validationResult.duplicatesInDatabase].map((question, index) => (
                        <div key={index} className="bg-yellow-50 border border-yellow-200 rounded p-2 text-sm">
                          <div className="font-medium text-yellow-900">
                            {question.lineNumber ? `Line ${question.lineNumber}: ` : ''}{question.question}
                          </div>
                          <div className="text-yellow-600 mt-1">{question.error}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {/* Valid Questions Preview */}
                {validationResult.validQuestions > 0 && (
                  <div>
                    <h4 className="font-medium text-green-900 mb-2 flex items-center">
                      <FileText className="h-4 w-4 mr-1" />
                      Valid Questions ({validationResult.validQuestions}) - Preview (First 3)
                    </h4>
                    <div className="space-y-2">
                      {validationResult.questions.slice(0, 3).map((question, index) => (
                        <div key={index} className="bg-green-50 border border-green-200 rounded p-2 text-sm">
                          <div className="font-medium text-green-900 mb-1">
                            Level {question.difficulty}: {question.question}
                          </div>
                          <div className="text-green-700 text-xs">
                            Choices: {question.choices.join(', ')}
                          </div>
                          <div className="text-green-600 text-xs mt-1">
                            Answer: {question.correctAnswer}
                          </div>
                        </div>
                      ))}
                      {validationResult.questions.length > 3 && (
                        <div className="text-center text-gray-500 text-sm">
                          ... and {validationResult.questions.length - 3} more questions
                        </div>
                      )}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        )}

        {/* Upload Progress */}
        {isUploading && (
          <div className="mt-4">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm font-medium text-gray-700">Processing...</span>
              <span className="text-sm text-gray-500">{uploadProgress}%</span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2">
              <div
                className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                style={{ width: `${uploadProgress}%` }}
              ></div>
            </div>
          </div>
        )}

        {/* Action Buttons */}
        <div className="flex justify-end space-x-3 mt-6 pt-4 border-t">
          <button
            onClick={handleClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500"
            disabled={isUploading || isValidating}
          >
            Cancel
          </button>
          
          {/* Validate Button (when file selected but not validated) */}
          {file && !validationResult && (
            <button
              onClick={handleValidateFile}
              disabled={isValidating}
              className="px-4 py-2 text-sm font-medium text-white bg-purple-600 border border-transparent rounded-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isValidating ? 'Validating...' : 'Validate Questions'}
            </button>
          )}
          
          {/* Import Button (when validation is complete and there are valid questions) */}
          {validationResult && validationResult.validQuestions > 0 && (
            <button
              onClick={handleUpload}
              disabled={isUploading}
              className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isUploading ? 'Importing...' : `Import ${validationResult.validQuestions} Questions`}
            </button>
          )}
          
          {/* Re-validate Button (when validation is complete) */}
          {validationResult && (
            <button
              onClick={handleValidateFile}
              disabled={isValidating}
              className="px-4 py-2 text-sm font-medium text-purple-600 bg-purple-50 border border-purple-300 rounded-md hover:bg-purple-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 disabled:opacity-50 disabled:cursor-not-allowed"
            >
              {isValidating ? 'Re-validating...' : 'Re-validate'}
            </button>
          )}
        </div>
      </div>

      {/* Bulk Import Modal */}
      {showBulkImportModal && (
        <BulkImportModal
          isOpen={showBulkImportModal}
          onClose={() => setShowBulkImportModal(false)}
          onSave={loadData}
          topicId={topicId}
          subtopicId={subtopicId}
          categoryId={categoryId}
        />
      )}
    </AdminLayout>
  );
}

// Bulk Import Modal Component
interface BulkImportModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSave: () => void;
  topicId: string;
  subtopicId: string;
  categoryId: string;
}

interface ValidationResult {
  totalQuestions: number;
  validQuestions: number;
  invalidQuestions: ParsedQuestion[];
  duplicatesInFile: ParsedQuestion[];
  duplicatesInDatabase: ParsedQuestion[];
  errors: string[];
  questions: ParsedQuestion[];
}

interface ParsedQuestion {
  question: string;
  choices: string[];
  correctAnswer: string;
  explanation?: string;
  difficulty: number;
  level_id?: string;
  lineNumber?: number;
  error?: string;
}

function BulkImportModal({ isOpen, onClose, onSave, topicId, subtopicId, categoryId }: BulkImportModalProps) {
  const [file, setFile] = useState<File | null>(null);
  const [isUploading, setIsUploading] = useState(false);
  const [isValidating, setIsValidating] = useState(false);
  const [dragActive, setDragActive] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const [validationResult, setValidationResult] = useState<ValidationResult | null>(null);
  const [showPreview, setShowPreview] = useState(false);

  const handleDrag = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    if (e.type === "dragenter" || e.type === "dragover") {
      setDragActive(true);
    } else if (e.type === "dragleave") {
      setDragActive(false);
    }
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      const droppedFile = e.dataTransfer.files[0];
      if (isValidFile(droppedFile)) {
        setFile(droppedFile);
      } else {
        toast.error('Please select a DOCX or CSV file');
      }
    }
  };

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0];
    if (selectedFile && isValidFile(selectedFile)) {
      setFile(selectedFile);
    } else {
      toast.error('Please select a DOCX or CSV file');
    }
  };

  const isValidFile = (file: File) => {
    return file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' ||
           file.type === 'text/csv' ||
           file.name.endsWith('.docx') ||
           file.name.endsWith('.csv');
  };

  const handleValidateFile = async () => {
    if (!file) {
      toast.error('Please select a file first');
      return;
    }

    setIsValidating(true);
    setValidationResult(null);

    try {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('topicId', topicId);
      formData.append('subtopicId', subtopicId);
      formData.append('categoryId', categoryId);

      let parsedQuestions: ParsedQuestion[] = [];

      if (file.name.endsWith('.docx')) {
        // Use the validateDocx endpoint
        const response = await questionsApi.validateDocx(formData);
        
        if (response.questions) {
          parsedQuestions = response.questions.map((q: any) => ({
            question: q.question || q.text,
            choices: q.choices || [],
            correctAnswer: q.correctAnswer || q.answer,
            explanation: q.explanation || '',
            difficulty: q.difficulty || q.level || 1,
            lineNumber: q.lineNumber
          }));
        }
      } else if (file.name.endsWith('.csv')) {
        // For CSV, parse client-side
        const fileContent = await readFileAsText(file);
        parsedQuestions = parseCSVContent(fileContent);
      }

      const validationResult = await validateQuestions(parsedQuestions, categoryId);
      setValidationResult(validationResult);
      setShowPreview(true);

      if (validationResult.errors.length > 0) {
        toast.error(`Validation completed with ${validationResult.errors.length} errors`);
      } else {
        toast.success(`Validation completed: ${validationResult.validQuestions}/${validationResult.totalQuestions} questions are valid`);
      }

    } catch (error: any) {
      console.error('Validation error:', error);
      toast.error('Failed to validate file: ' + error.message);
    } finally {
      setIsValidating(false);
    }
  };

  const readFileAsText = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target?.result as string);
      reader.onerror = (e) => reject(new Error('Failed to read file'));
      reader.readAsText(file, 'UTF-8');
    });
  };

  const parseCSVContent = (content: string): ParsedQuestion[] => {
    const questions: ParsedQuestion[] = [];
    const lines = content.split('\n').map(line => line.trim()).filter(line => line);
    
    if (lines.length === 0) return questions;
    
    // Skip header if present
    const startIndex = lines[0].toLowerCase().includes('level') ? 1 : 0;
    
    for (let i = startIndex; i < lines.length; i++) {
      const line = lines[i];
      const columns = parseCSVLine(line);
      
      if (columns.length >= 7) {
        questions.push({
          difficulty: parseInt(columns[0]) || 1,
          question: columns[1],
          choices: [columns[2], columns[3], columns[4], columns[5]],
          correctAnswer: columns[6],
          explanation: columns[7] || '',
          lineNumber: i + 1
        });
      }
    }
    
    return questions;
  };

  const parseCSVLine = (line: string): string[] => {
    const result: string[] = [];
    let current = '';
    let inQuotes = false;
    
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      
      if (char === '"') {
        inQuotes = !inQuotes;
      } else if (char === ',' && !inQuotes) {
        result.push(current.trim());
        current = '';
      } else {
        current += char;
      }
    }
    
    result.push(current.trim());
    return result.map(col => col.replace(/^"|"$/g, ''));
  };

  const validateQuestions = async (parsedQuestions: ParsedQuestion[], categoryId: string): Promise<ValidationResult> => {
    const result: ValidationResult = {
      totalQuestions: parsedQuestions.length,
      validQuestions: 0,
      invalidQuestions: [],
      duplicatesInFile: [],
      duplicatesInDatabase: [],
      errors: [],
      questions: []
    };
    
    // Get existing questions from database
    let existingQuestions: Question[] = [];
    try {
      const response = await questionsApi.getAll({ categoryId, limit: 1000 });
      existingQuestions = response.data || [];
    } catch (error) {
      result.errors.push('Failed to fetch existing questions from database');
    }
    
    // Track questions for duplicate detection
    const seenTexts = new Set<string>();
    const duplicateTexts = new Set<string>();
    
    // First pass: find duplicates within the file
    parsedQuestions.forEach(q => {
      const normalizedText = q.question.toLowerCase().trim();
      if (seenTexts.has(normalizedText)) {
        duplicateTexts.add(normalizedText);
      }
      seenTexts.add(normalizedText);
    });
    
    // Second pass: validate each question
    parsedQuestions.forEach(question => {
      const normalizedText = question.question.toLowerCase().trim();
      let isValid = true;
      const errors: string[] = [];
      
      // Check required fields
      if (!question.question?.trim()) {
        errors.push('Question text is required');
        isValid = false;
      }
      
      if (!question.correctAnswer?.trim()) {
        errors.push('Correct answer is required');
        isValid = false;
      }
      
      if (!question.choices || question.choices.length < 2) {
        errors.push('At least 2 answer choices are required');
        isValid = false;
      }
      
      if (question.choices && question.choices.some(choice => !choice?.trim())) {
        errors.push('All answer choices must be filled');
        isValid = false;
      }
      
      // Check if correct answer is in choices
      if (question.choices && question.correctAnswer && 
          !question.choices.some(choice => choice.toLowerCase().trim() === question.correctAnswer.toLowerCase().trim())) {
        errors.push('Correct answer must be one of the provided choices');
        isValid = false;
      }
      
      // Check for duplicates in file
      if (duplicateTexts.has(normalizedText)) {
        result.duplicatesInFile.push({ ...question, error: 'Duplicate question in file' });
        isValid = false;
      }
      
      // Check for duplicates in database
      const existsInDb = existingQuestions.some(existing => 
        existing.question.toLowerCase().trim() === normalizedText
      );
      
      if (existsInDb) {
        result.duplicatesInDatabase.push({ ...question, error: 'Question already exists in database' });
        isValid = false;
      }
      
      if (isValid) {
        result.validQuestions++;
        result.questions.push(question);
      } else {
        result.invalidQuestions.push({ ...question, error: errors.join(', ') });
      }
    });
    
    return result;
  };

  const handleUpload = async () => {
    if (!validationResult || validationResult.validQuestions === 0) {
      toast.error('Please validate the file first and ensure there are valid questions');
      return;
    }

    setIsUploading(true);
    setUploadProgress(0);

    try {
      // Get available levels for this category
      let availableLevels: any[] = [];
      try {
        const levelsResponse = await levelsApi.getAll({ category_id: categoryId, limit: 100 });
        availableLevels = levelsResponse.data || [];
      } catch (error) {
        console.error('Failed to fetch levels:', error);
      }

      // Prepare questions for API
      const questionsToCreate = validationResult.questions.map(q => {
        // Find appropriate level based on difficulty or use first available level
        const appropriateLevel = availableLevels.find(level => level.level === q.difficulty) || 
                               availableLevels[0];
        
        return {
          topic_id: topicId,
          subtopic_id: subtopicId,
          category_id: categoryId,
          level_id: appropriateLevel?.id || '',
          question: q.question,
          choices: q.choices,
          correctAnswer: q.correctAnswer,
          explanation: q.explanation || '',
          difficulty: q.difficulty,
          tags: [],
          estimatedTime: 60,
          isActive: true
        };
      });

      // Simulate progress
      const progressInterval = setInterval(() => {
        setUploadProgress(prev => {
          if (prev >= 90) {
            clearInterval(progressInterval);
            return prev;
          }
          return prev + 10;
        });
      }, 200);

      // Use bulk create API
      const response = await questionsApi.bulkCreate({
        topicId,
        subtopicId,
        categoryId,
        questionsData: questionsToCreate
      });

      clearInterval(progressInterval);
      setUploadProgress(100);

      if (response.success) {
        toast.success(`Successfully imported ${validationResult.validQuestions} questions`);
        handleClose();
        onSave();
      } else {
        toast.error(response.message || 'Failed to import questions');
      }

    } catch (error: any) {
      console.error('Upload error:', error);
      toast.error('Failed to import questions: ' + (error.response?.data?.error || error.message));
    } finally {
      setIsUploading(false);
      setUploadProgress(0);
    }
  };

  const handleClose = () => {
    setFile(null);
    setValidationResult(null);
    setShowPreview(false);
    setIsValidating(false);
    setIsUploading(false);
    setUploadProgress(0);
    onClose();
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
      <div className="bg-white rounded-lg p-6 w-full max-w-4xl max-h-[90vh] overflow-y-auto">
        <div className="flex items-center justify-between mb-6">
          <h2 className="text-xl font-bold text-gray-900">Bulk Import Questions</h2>
          <button
            onClick={handleClose}
            className="text-gray-400 hover:text-gray-600"
            disabled={isUploading || isValidating}
          >
            ×
          </button>
        </div>

        {/* File Format Info */}
        <div className="mb-6">
          <h3 className="text-lg font-semibold text-gray-900 mb-3">Supported Formats</h3>
          
          {/* DOCX Format */}
          <div className="mb-4 p-4 bg-blue-50 rounded-lg">
            <h4 className="font-medium text-blue-900 mb-2 flex items-center">
              <FileText className="h-4 w-4 mr-2" />
              DOCX Format (Recommended)
            </h4>
            <p className="text-sm text-blue-800 mb-2">Upload your Word document with questions formatted as:</p>
            <div className="bg-white p-3 rounded border text-sm font-mono whitespace-pre-line">
{`Question 1 – (Easy)
Who is known as the Firebrand and was one of the founding members of the Gatewatch?
A) Liliana Vess
B) Chandra Nalaar  
C) Jaya Ballard
D) Elspeth Tirel
Answer: B) Chandra Nalaar`}
            </div>
          </div>

          {/* CSV Format */}
          <div className="mb-4 p-4 bg-green-50 rounded-lg">
            <h4 className="font-medium text-green-900 mb-2 flex items-center">
              <FileText className="h-4 w-4 mr-2" />
              CSV Format
            </h4>
            <p className="text-sm text-green-800 mb-2">Download template with required columns:</p>
            <button
              onClick={() => {
                const csvContent = [
                  'level,question,option_a,option_b,option_c,option_d,correct_answer,explanation',
                  '1,"Who is known as the Firebrand?","Liliana Vess","Chandra Nalaar","Jaya Ballard","Elspeth Tirel","Chandra Nalaar","Chandra is the Firebrand"'
                ].join('\n');
                
                const blob = new Blob([csvContent], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'questions_template.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                toast.success('CSV template downloaded');
              }}
              className="bg-green-600 text-white px-3 py-1 rounded text-sm hover:bg-green-700 transition-colors"
              disabled={isUploading || isValidating}
            >
              Download CSV Template
            </button>
          </div>
        </div>

        {/* File Upload Area */}
        <div
          className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
            dragActive
              ? 'border-blue-500 bg-blue-50'
              : file
              ? 'border-green-500 bg-green-50'
              : 'border-gray-300 hover:border-gray-400'
          }`}
          onDragEnter={handleDrag}
          onDragLeave={handleDrag}
          onDragOver={handleDrag}
          onDrop={handleDrop}
        >
          {file ? (
            <div className="space-y-2">
              <FileText className="h-12 w-12 text-green-600 mx-auto" />
              <p className="text-sm font-medium text-green-900">{file.name}</p>
              <p className="text-xs text-green-600">
                {(file.size / 1024 / 1024).toFixed(2)} MB • {file.type || file.name.split('.').pop()?.toUpperCase()}
              </p>
              <button
                onClick={() => setFile(null)}
                className="text-red-600 hover:text-red-800 text-sm"
                disabled={isUploading || isValidating}
              >
                Remove file
              </button>
            </div>
          ) : (
            <div className="space-y-4">
              <Upload className="h-12 w-12 text-gray-400 mx-auto" />
              <div>
                <p className="text-lg font-medium text-gray-900">Drop your file here</p>
                <p className="text-sm text-gray-500">or click to browse</p>
              </div>
              <input
                type="file"
                accept=".docx,.csv"
                onChange={handleFileChange}
                className="hidden"
                id="file-upload"
                disabled={isUploading || isValidating}
              />
              <label
                htmlFor="file-upload"
                className="bg-blue-600 text-white px-4 py-2 rounded-lg cursor-pointer hover:bg-blue-700 transition-colors inline-block"
              >
                Choose File
              </label>
            </div>
          )}
        </div>

        {/* Validation Results */}
        {validationResult && (
          <div className="mt-6 space-y-4">
            <div className="bg-gray-50 rounded-lg p-4">
              <h3 className="font-semibold text-gray-900 mb-3">Validation Results</h3>
              
              {/* Summary Cards */}
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
                <div className="bg-white rounded-lg p-3 text-center">
                  <div className="text-2xl font-bold text-blue-600">{validationResult.totalQuestions}</div>
                  <div className="text-sm text-gray-600">Total</div>
                </div>
                <div className="bg-white rounded-lg p-3 text-center">
                  <div className="text-2xl font-bold text-green-600">{validationResult.validQuestions}</div>
                  <div className="text-sm text-gray-600">Valid</div>
                </div>
                <div className="bg-white rounded-lg p-3 text-center">
                  <div className="text-2xl font-bold text-red-600">{validationResult.invalidQuestions.length}</div>
                  <div className="text-sm text-gray-600">Invalid</div>
                </div>
                <div className="bg-white rounded-lg p-3 text-center">
                  <div className="text-2xl font-bold text-yellow-600">
                    {validationResult.duplicatesInFile.length + validationResult.duplicatesInDatabase.length}
                  </div>
                  <div className="text-sm text-gray-600">Duplicates</div>
                </div>
              </div>

              {/* Show Details Button */}
              <div className="flex justify-center">
                <button
                  onClick={() => setShowPreview(!showPreview)}
                  className="text-blue-600 hover:text-blue-800 text-sm flex items-center"
                >
                  {showPreview ? 'Hide Details' : 'Show Details'}
                  <ChevronRight className={`h-4 w-4 ml-1 transition-transform ${showPreview ? 'rotate-90' : ''}`} />
                </button>
              </div>
            </div>

            {/* Detailed Preview */}
            {showPreview && validationResult && (
              <div className="bg-gray-50 rounded-lg p-4 max-h-96 overflow-y-auto">
                {/* Valid Questions Preview */}
                {validationResult.validQuestions > 0 && (
                  <div className="mb-4">
                    <h4 className="font-medium text-green-900 mb-2">✅ Valid Questions ({validationResult.validQuestions})</h4>
                    <div className="space-y-2">
                      {validationResult.questions.slice(0, 3).map((question, index) => (
                        <div key={index} className="bg-green-50 border border-green-200 rounded p-2 text-sm">
                          <div className="font-medium text-green-900">{question.question}</div>
                          <div className="text-green-600 text-xs mt-1">Answer: {question.correctAnswer}</div>
                        </div>
                      ))}
                      {validationResult.questions.length > 3 && (
                        <div className="text-center text-gray-500 text-sm">
                          ... and {validationResult.questions.length - 3} more
                        </div>
                      )}
                    </div>
                  </div>
                )}

                {/* Invalid Questions */}
                {validationResult.invalidQuestions.length > 0 && (
                  <div className="mb-4">
                    <h4 className="font-medium text-red-900 mb-2">❌ Invalid Questions ({validationResult.invalidQuestions.length})</h4>
                    <div className="space-y-2">
                      {validationResult.invalidQuestions.slice(0, 3).map((question, index) => (
                        <div key={index} className="bg-red-50 border border-red-200 rounded p-2 text-sm">
                          <div className="font-medium text-red-900">{question.question || 'Missing question text'}</div>
                          <div className="text-red-600 text-xs mt-1">{question.error}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}

                {/* Duplicates */}
                {(validationResult.duplicatesInFile.length + validationResult.duplicatesInDatabase.length) > 0 && (
                  <div>
                    <h4 className="font-medium text-yellow-900 mb-2">⚠️ Duplicate Questions</h4>
                    <div className="space-y-2">
                      {[...validationResult.duplicatesInFile, ...validationResult.duplicatesInDatabase].slice(0, 3).map((question, index) => (
                        <div key={index} className="bg-yellow-50 border border-yellow-200 rounded p-2 text-sm">
                          <div className="font-medium text-yellow-900">{question.question}</div>
                          <div className="text-yellow-600 text-xs mt-1">{question.error}</div>
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}
          </div>
        )}

        {/* Upload Progress */}
        {isUploading && (
          <div className="mt-4">
            <div className="flex items-center justify-between mb-2">
              <span className="text-sm font-medium text-gray-700">Importing questions...</span>
              <span className="text-sm text-gray-500">{uploadProgress}%</span>
            </div>
            <div className="w-full bg-gray-200 rounded-full h-2">
              <div
                className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                style={{ width: `${uploadProgress}%` }}
              ></div>
            </div>
          </div>
        )}

        {/* Action Buttons */}
        <div className="flex justify-end space-x-3 mt-6 pt-4 border-t">
          <button
            onClick={handleClose}
            className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200"
            disabled={isUploading || isValidating}
          >
            Cancel
          </button>
          
          {/* Validate Button */}
          {file && !validationResult && (
            <button
              onClick={handleValidateFile}
              disabled={isValidating}
              className="px-4 py-2 text-sm font-medium text-white bg-purple-600 border border-transparent rounded-md hover:bg-purple-700 disabled:opacity-50"
            >
              {isValidating ? 'Validating...' : 'Validate Questions'}
            </button>
          )}
          
          {/* Import Button */}
          {validationResult && validationResult.validQuestions > 0 && (
            <button
              onClick={handleUpload}
              disabled={isUploading}
              className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 disabled:opacity-50"
            >
              {isUploading ? 'Importing...' : `Import ${validationResult.validQuestions} Questions`}
            </button>
          )}
          
          {/* Re-validate Button */}
          {validationResult && (
            <button
              onClick={handleValidateFile}
              disabled={isValidating}
              className="px-4 py-2 text-sm font-medium text-purple-600 bg-purple-50 border border-purple-300 rounded-md hover:bg-purple-100 disabled:opacity-50"
            >
              Re-validate
            </button>
          )}
        </div>
      </div>
    </div>
  );
}
